---
title: "Clase 2. Tidyverse"
author: "Diego Kozlowski y Juan Barriola"
date: "25 de Agosto de 2018"
output: 
  html_notebook: 
    toc: true
    toc_float: true
    depth: 2
---

```{r, warning=FALSE}
rm(list=ls())
```

# [Tidyverse](https://www.tidyverse.org/)         

Este paquete agrupa una serie de paquetes que tienen una misma lógica en su diseño y por ende funcionan en armonía.     
Entre ellos usaremos principalmente __ggplot__ para realizar gráficos, y __dplyr__ y __tidyr__ para realizar transformaciones sobre nuestro set de datos.

A continuación cargamos la librería a nuestro ambiente. Para ello debe estar previamente instalada en nuestra pc.
```{r}
library(tidyverse)
```

Para mostrar el funcionamiento básico de tydyverse retomaremos el ejemplo de la clase 1, con lo cual volvemos a crear el set de datos del [Indice de salarios](http://www.indec.gob.ar/bajarCuadroEstadistico.asp?idc=4020B33440609462654542BD0BC320F1523DA0DC52C396201DB4DD5861FFEDC9AD1436681AC84179).

```{r, warning=FALSE}

INDICE  <- c(100,   100,   100,
             101.8, 101.2, 100.73,
             102.9, 102.4, 103.2)

FECHA  <-  c("Oct-16", "Oct-16", "Oct-16",
             "Nov-16", "Nov-16", "Nov-16",
             "Dic-16", "Dic-16", "Dic-16")


GRUPO  <-  c("Privado_Registrado","Público","Privado_No_Registrado",
             "Privado_Registrado","Público","Privado_No_Registrado",
             "Privado_Registrado","Público","Privado_No_Registrado")

Datos <- data.frame(INDICE, FECHA, GRUPO)
```


## Dplyr

El caracter principal para utilizar este paquete es ```%>%``` , _pipe_ (de tubería).

Los ```%>%``` toman el set de datos a su izquierda, y los transforman mediante los comandos a su derecha, en los cuales los elementos de la izquierda están implícitos. En otros términos.

$f(x,y)$ es equivalente a $x$ %>% $f(.,y)$ 

Veamos las principales funciones que pueden utilizarse con la lógica de este paquete:

### filter

Permite filtrar la tabla acorde al cumplimiento de condiciones lógicas
 
```{r}
Datos %>% 
  filter(INDICE>101 , GRUPO == "Privado_Registrado")
```

Nótese que en este caso al separar con una  __,__ las condiciones se exige el cumplimiento de ambas. En caso de desear que se cumpla una sola condición debe utilizarse el caracter __|__

```{r}
Datos %>% 
  filter(INDICE>101 | GRUPO == "Privado_Registrado")
```

### rename
Permite renombrar una columna de la tabla. Funciona de la siguiente manera: 
 ```Data %>% rename( nuevo_nombre = viejo_nombre )``` 
```{r}
Datos %>% 
  rename(Periodo = FECHA)
```
Nótese que a diferencia del ejemplo de la función __filter__ donde utilizábamos __==__ para comprobar una condición lógica, en este caso se utiliza sólo un __=__ ya que lo estamos haciendo es _asignar_ un nombre.

### mutate
Permite agregar una variable a la tabla (especificando el nombre que tomará esta), que puede ser el resultado de operaciones sobre otras variables de la misma tabla.       

En caso de especificar el nombre de una columna existente, el resultado de la operación realizada "sobrescribirá" la información de la columna con dicho nombre
```{r}
Datos <- Datos %>% 
  mutate(Doble=INDICE*2)
Datos
```

### case_when
Permite definir una variable, la cual toma un valor particular para cada condición establecida. En caso de no cumplir ninguna de las condiciones establecidas la variable tomara valor __NA__
La sintaxis de la función es case_when( _condicion lógica1_ __~__ _valor asignado1_).

```{r}
Datos <- Datos %>% 
  mutate(Caso_cuando = case_when(GRUPO == "Privado_Registrado"   ~ INDICE*2,
                                 GRUPO == "Público"              ~ INDICE*3,
                                 GRUPO == "Privado_No_Registrado"~ INDICE*5))
Datos
```

### select
Permite especificar la serie de columnas que se desea conservar de un DataFrame. También pueden especificarse las columnas que se desean descartar (agregándoles un _-_). Muy útil para agilizar el trabajo en bases de datos de gran tamaño.
```{r}
Datos2 <- Datos %>% 
  select(INDICE, FECHA, GRUPO)
Datos2

Datos <- Datos %>% 
  select(-c(Doble,Caso_cuando))
Datos
```

### arrange
Permite ordenar la tabla por los valores de determinada/s variable/s. Es útil cuando luego deben hacerse otras operaciones que requieran del ordenamiento de la tabla
```{r}
Datos <- Datos %>% 
  arrange(GRUPO, INDICE)
Datos
```

### summarise
Crea una nueva tabla que resuma la información original. Para ello, definimos las variables de resumen y las formas de agregación.
```{r}
Datos %>% 
  summarise(Indprom = mean(INDICE))

```

### group_by
Esta función permite realizar operaciones de forma agrupada. Lo que hace la función es "separar" a la tabla según los valores de la variable indicada y realizar las operaciones que se especificaba  continuación, de manera independiente para cada una de las "subtablas". En nuestro ejemplo, sería útil para calcular el promedio de los indices por _Fecha_ 
```{r}
Datos %>% 
  group_by(FECHA) %>%
  summarise(Indprom = mean(INDICE))
```

## Joins

Otra implementación muy importante del paquete dplyr son las funciones para unir tablas (joins)


![fuente: http://rstudio-pubs-static.s3.amazonaws.com/227171_618ebdce0b9d44f3af65700e833593db.html](joins.png)         

###left_join    

Veamos un ejemplo de la función __left_join__ (una de las más utilizadas en la práctica).       
Para ello crearemos previamente un Dataframe que contenga un Ponderador para cada uno de los Grupos del Dataframe _Datos_. Aprovecharemos el ejemplo para introducir la función __weigthed.mean__, y así calcular un Indice Ponderado.

```{r}
Ponderadores <- data.frame(GRUPO = c("Privado_Registrado","Público","Privado_No_Registrado"),
                            PONDERADOR = c(50.16,29.91,19.93))

Datos_join <- Datos %>% 
  left_join(.,Ponderadores, by = "GRUPO")
Datos_join

Datos_Indice_Gral <- Datos_join %>% 
  group_by(FECHA) %>% 
  summarise(Indice_Gral = weighted.mean(INDICE,w = PONDERADOR))

Datos_Indice_Gral
```

## Tidyr

El paquete tidyr esta pensado para facilitar el emprolijamiento de los datos.

__Gather__ es una función que nos permite pasar los datos de forma horizontal a una forma vertical. 

__spread__ es una función que nos permite pasar los datos de forma vertical a una forma horizontal.

![fuente: http://www.gis-blog.com/data-management-with-r-tidyr-part-1/](spreadVSgather.png)


```{r}
#Utilzamos un conjunto de datos que viene con la librería datasets
library(datasets)

data(iris)
iris <- iris %>% 
  mutate(id = 1:nrow(.)) %>%  #le agrego un ID
  select(id, everything()) # lo acomodo para que el id este primero. 

iris
```


  
### Gather y Spread

```{r}
iris_vertical <- iris %>% gather(., # el . llama a lo que esta atras del %>% 
                                 key   = Variables,
                                 value = Valores,
                                 2:5) #le indico que columnas juntar
iris_vertical
```

Podemos deshacer el __gather__ con un __Spread__
```{r}
iris_horizontal <- iris_vertical %>%
  spread(. ,
         key   = Variables, #la llave es la variable que va a dar los nombres de columna
         value = Valores) #los valores con que se llenan las celdas
iris_horizontal
```

